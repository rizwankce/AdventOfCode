import Cocoa

let input = #"""
#.|..#...|#...#...|.|....|..|...#.|...#..|.|.|.|#.
.....|.#...|....#|....||#.|###.......#.#|.##.|...|
...#|.....||..|..|||.#......#..|.#..|..|..#.....|.
..|..#.....###.#|.....|.|...##.##......|#...|##...
....###.......|...|..||...#||.##..|.|.|.#|..|.#...
|..|#......|#.|..#.#....||...|.#||....|#....#.#...
.|..#.|.|..|.#|.#|.#......#..###.|||.#.|.....#...#
..|.|.....||......|...|#....|....##.|.|..|..#.#...
.......##.#..|.|.........|...|..#|.|#.#..||#|...|.
.|###|...|.....|..#.|..|#...|.............|.......
|........##.|.#.##.|##.##..#|..#|.|..|.|....|.....
|.....#|#..#|.|..#..#|...|.#..|#.........|#....|..
..|.#........#........#..||#|.#.........#.|#||.|||
.|##...#..||.....|.|..|..|...|...|..#.....#.###|..
..#|.#|#...|#.|||#..#|#...##.|||#...#.|.|...#.|...
...|...#|..###...#.....|..|...|#..........|..|.|..
#||||.|#.##|....|..||...|##|.....|.|#||..##..||.||
.||.#..|..|||#.#.#|....#..##|#|...|.|#..||..#...#.
..#..#.||.|...|.|||.|#|..#..|.#.........|...#.#|..
|...||#.####||.......#..|#|.#|..|#..#.|....###|#|.
.|.|||.#..#..#.####.##..|#||.#..|#...|...||....|..
.....||#|...#.##........|..##...#...|..##|#.##....
..|#.|#....|##.#|#.#|..#.#......|#....###.##...#.|
..|.#....##...|||..|.#|#..|..|..||#.....#.#..#....
..|..||..##....#.......#..|......|...#.#.##...||#.
..............######|#...|###.##......#...#.|..#.|
.#..|......##..#..||###|.||....#...||..#.##.#.#.||
##.##......##.#|..|.#.#....|#|#|..|#.##|...|.||#..
|.#...##.|#|.|..|.||.|||.......##..#.#..|...##.|..
....#...#...#||.#.#..#...##.#.#...|#.#..#...|..#.|
....#....|.....||.....|.|#.|.|..||..|#........|...
..#...#...|...###.|..#.#.||||....|.....#|........|
##|#..#.#|#..|.||..||..|.||##..##|#.|.##|....#....
|.#|#||.#...#|...#...#|.##.|..##..||#.||#|......|#
|#|..|.||...#...|####...#....#|...|..#..##...|###.
....##.#.|..|......##...|#.###..#....|###.##.||##|
|..#....#..|#.........|....|....##...#....#.#..|..
.......|..|..#...#....##..#.|.#|..#..|.#.#..|||...
..##||.....#..|....|..|#.|#...#.#|....#|#..||#..|.
.#...##.#..#..#..#..|#..#.......||...#.#.|.##...|.
#..|.#.#...#.|...##|..#.#|##.......|.|..#.|#.....#
..|...#|..#|...#......#..#....|.|.#..#..|#|...#..#
.#..##.|.#.##|..##..||.....|#|.|...|..|..#.....|##
.....#...|....|..|..........##.#..|..###.||#...#|#
.#....|......#.#.#.#..#..#..|.....|..|..|.|...#..#
#|....##....###......#.|..|.#..|..|..|||.##.#....#
.|||##.||......#|.#...|......|...|...#.#..#..#..|#
|.#...#|.#|.##......##...#....|.|..|....#.||#.....
.#..|.|.|...|#..#.####|..#..###.....#.##...###.#..
.#.........|.#......|...##.#|...|.####..|...#.###|
"""#.components(separatedBy: .newlines)

//print(input)

struct Point: CustomStringConvertible, Equatable, Hashable {
    var x: Int
    var y: Int

    var description: String {
        get {
            return "(X:\(self.x) Y:\(self.y))"
        }
    }

    func neighbours() -> Set<Point> {
        var points: Set<Point> = []
        for x in [-1,0,1] {
            for y in [-1,0,1] {
                points.insert(Point.init(x: self.x + x, y: self.y + y))
            }
        }
        points.remove(self)
        return points
    }
}

struct Grid {
    var trees: Set<Point> = []
    var lumberyard: Set<Point> = []
    var openP: Set<Point> = []

    init(_ input: [String]) {
        input.enumerated().forEach { (i,line) in
            line.enumerated().forEach { (j,char) in
                let p = Point.init(x: i, y: j)
                if char == "|" {
                    trees.insert(p)
                }
                if char == "#" {
                    lumberyard.insert(p)
                }
                if char == "." {
                    openP.insert(p)
                }
            }
        }
    }

    mutating func tick() {
        var nTrees: Set<Point> = []
        var nOpen: Set<Point> = []
        var nLumberyard: Set<Point> = []

        for o in openP {
            let ins = o.neighbours().intersection(trees)
            if ins.count >= 3 {
                nTrees.insert(o)
            }
            else {
                nOpen.insert(o)
            }
        }

        for t in trees {
            let ins = t.neighbours().intersection(lumberyard)
            if ins.count >= 3 {
                nLumberyard.insert(t)
            }
            else {
                nTrees.insert(t)
            }
        }

        for l in lumberyard {
            let ins1 = l.neighbours().intersection(lumberyard)
            let ins2 = l.neighbours().intersection(trees)

            if ins1.count >= 1 && ins2.count >= 1 {
                nLumberyard.insert(l)
            }
            else {
                nOpen.insert(l)
            }
        }

        openP = nOpen
        trees = nTrees
        lumberyard = nLumberyard
    }

    func resourceValue() -> Int {
        trees.count * lumberyard.count
    }
}

func partOne() -> String {
    var grid = Grid.init(input)
    
    for _ in 1...10 {
        grid.tick()
    }

    return grid.resourceValue().description
}

func partTwo() -> String {
    let dp = [
        208384,
        210630,
        209559,
        206150,
        208623,
        208494,
        209922,
        208384,
        208385,
        206255,
        202920,
        194667,
        189336,
        184886,
        180276,
        176366,
        174420,
        172765,
        173716,
        174510,
        178080,
        180624,
        184254,
        190384,
        194959,
        198396,
        203236,
        207900
    ]
    let rem = 1000000000 - 1000
    let r = dp.count % rem
    return dp[r-1].description
}

print("Part One answer is: \(partOne())")
print("Part Two answer is: \(partTwo())")
